(namespace hello)

;; Constant (can't be redef)
(def Float pi 3.14f)

;; Functions
(defun add (Int a Int b)
  (+ a b))

(defun main ()
  (IO.puts "Hello, World!"))

(defun fib
  (Int number) Int
  (fib number 1 0)

  (Int number Int prev Int current) Int
  (if (<= number 0)
    current
    (tailrec (dec number) (+ prev current) prev)))

;; Protocols are like interfaces, but types does not need to explicitly implement them
;; Once the method exists in the type it will be accepted
(defprotocol Equals<T>
  (defmethod eq (T T) Boolean))

;; Example of the equals function that expected two parameters with the same type that must
;; implement the equals protocol
(defun = <T> (Equals<T> first Equals<T> seccond)
  (Equals.eq first seccond))

;; Classes
(class Person
  (attributes
    (public  String  :name)
    (public  Int     :age)
    (private Boolean :can-drink?)
    (private Boolean :virgin?))

  ;; Private arguments must have a default value since it can be passed as argument
  (defaults :virgin?    true
            :can-drink? false)

  ;; Init is like an object constructor. After an instance is made, this method is called
  (init (this.update-can-drink?))

  (private defmethod is-of-age? () Boolean
     (>= (:age this) 18))

  (private defmethod update-can-drink? () Boolean
     (this.with :can-drink? (this.is-of-age?)))

  (defmethod rename (String name) Person
    (this.with :name name))

  (defmethod make-birthday () Person
    (-> this
        (Person.update :age (partial + 1))
        (Person.update-can-drink?)))

(def person
  (Person
    :name "Maniero"
    :age  28))

(deftype Maybe <T> (None Just<T>)
  (defmethod or-else (T default) T
    (match this
      (None)       default
      (Just value) value))

  (defmethod map <S> (Lambda<(T) S> mapper) Maybe<T>
    (match this
      (None)       (None)
      (Just value) (Just (mapper value))))

  (defmethod none? () Boolean
    (-> (this.map (lambda (_) false))
        (Maube.or-else true))))


(defun compare-maybe <T> (Maybe<Equals<T> first Maybe<Equals<T>> second) Boolean
  (match first
    (None)       (second.none?)
    (Just value) (-> second
                     (Maybe.map (lambda (second-value) (= value second-value)))
                     (Maybe.or-else false))))

(= (Just (Integer 2))
   (Maybe.map inc (Just (Integer 1))))

(comment
  "how to use Maybe map"
  (Maybe.map
   (Maybe.map (Just 1) inc)))
